作用：通过原型实例指定要实例创建的对象，并通过复制原型创建新的对象

适用性：	
	使用原型模式当系统独立于产品如何生成，组装，表现并且
	1.当要实例化的类在运行时指定时，或
	2.为了避免构建与产品的类层次结构平行的工厂类层次结构（即用原型模式实现工厂模式），或
	3.当一个类的实例只有几种状态不同时，安装相应的原型并克隆它们可能比手动实例化类更方便。

合作：
	1.客户端要求原型克隆它自己。

利弊：
     利：
	1.隔绝具体的类，客户端不会出现产品中具体的子类。
	2.添加或移除产品在运行时。它可以让你添加一个确定的产品类到系统中通过在客户端储存一个原型实例，这比工厂模式更加灵活。因为客户端可以在运行时进行添加或删除一个原型类。
	3.指定新对象通过不同值。客户端可以通过原型实例化对象，也可以储存实例化对象作为原型。客户端可将展示新行为的责任交给原型（即通过原型不同来展示不同的行为）
	4.指定新对象通过不同结构。有的project由product和subproduct组成。原型模式可以储存相应的结构。前提是product也实现了clone方法
	5.减少子类。与工厂方法相比，原型可以减少与产品类同层级的factory类。
  弊:
	所有的prototype必须实现Clone方法。当实现Deep Clone时需要编写较为复杂的代码。

相关设计模式：
	1.抽象工厂经常用工厂模式生成，有时也可以用原型模式实现。
	2.大量使用Composite和Decorator模式的设计也可以从Prototype中受益